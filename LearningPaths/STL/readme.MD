# c++ STL

## ç®€ä»‹

C++çš„ STLï¼ˆæ ‡å‡†æ¨¡æ¿åº“ï¼‰æ˜¯ C++æ ‡å‡†åº“çš„ä¸€ä¸ªç»„æˆéƒ¨åˆ†ï¼Œæä¾›äº†è®¸å¤šé€šç”¨çš„æ¨¡æ¿ç±»å’Œå‡½æ•°ï¼Œç”¨äºå®ç°å¸¸è§çš„æ•°æ®ç»“æ„å’Œç®—æ³•ã€‚STL æ—¨åœ¨æé«˜ C++çš„ä»£ç é‡ç”¨æ€§ã€å¯è¯»æ€§å’Œçµæ´»æ€§ã€‚ä»¥ä¸‹æ˜¯ STL ä¸­ä¸€äº›é‡è¦çš„ç»„ä»¶ï¼š

1. **å®¹å™¨ï¼ˆContainersï¼‰ï¼š**
   - **å‘é‡ï¼ˆVectorï¼‰ï¼š** åŠ¨æ€æ•°ç»„ï¼Œæ”¯æŒå¿«é€Ÿçš„éšæœºè®¿é—®ã€‚
   - **åˆ—è¡¨ï¼ˆListï¼‰ï¼š** åŒå‘é“¾è¡¨ã€‚
   - **é˜Ÿåˆ—ï¼ˆQueueï¼‰ï¼š** é˜Ÿåˆ—ï¼Œæ”¯æŒå…ˆè¿›å…ˆå‡ºï¼ˆFIFOï¼‰çš„æ“ä½œã€‚
   - **æ ˆï¼ˆStackï¼‰ï¼š** æ ˆï¼Œæ”¯æŒåè¿›å…ˆå‡ºï¼ˆLIFOï¼‰çš„æ“ä½œã€‚
   - **é›†åˆï¼ˆSetï¼‰ï¼š** ä¸é‡å¤å…ƒç´ çš„é›†åˆã€‚
   - **æ˜ å°„ï¼ˆMapï¼‰ï¼š** é”®-å€¼å¯¹çš„é›†åˆã€‚
2. **ç®—æ³•ï¼ˆAlgorithmsï¼‰ï¼š**
   - **æ’åºï¼ˆSortï¼‰ï¼š** `sort` å‡½æ•°ç”¨äºæ’åºåºåˆ—ã€‚
   - **æŸ¥æ‰¾ï¼ˆSearchï¼‰ï¼š** `find` å‡½æ•°ç”¨äºæŸ¥æ‰¾å…ƒç´ ã€‚
   - **å˜æ¢ï¼ˆTransformï¼‰ï¼š** `transform` å‡½æ•°ç”¨äºå¯¹åºåˆ—è¿›è¡Œå˜æ¢æ“ä½œã€‚
   - **åˆå¹¶ï¼ˆMergeï¼‰ï¼š** `merge` å‡½æ•°ç”¨äºåˆå¹¶ä¸¤ä¸ªæœ‰åºåºåˆ—ã€‚
   - **è¿­ä»£å™¨ï¼ˆIteratorsï¼‰ï¼š** æä¾›äº†è¿­ä»£å™¨æ¥è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ã€‚
3. **å‡½æ•°å¯¹è±¡ï¼ˆFunction Objectsï¼‰ï¼š**
   - **è°“è¯ï¼ˆPredicatesï¼‰ï¼š** å¯è°ƒç”¨å¯¹è±¡ï¼Œç”¨äºåœ¨ç®—æ³•ä¸­å®šä¹‰æ¡ä»¶ã€‚
   - **å‡½æ•°é€‚é…å™¨ï¼ˆFunction Adaptersï¼‰ï¼š** `bind` å’Œ `function` ç­‰é€‚é…å™¨ã€‚
4. **è¿­ä»£å™¨ï¼ˆIteratorsï¼‰ï¼š**
   - **è¾“å…¥è¿­ä»£å™¨ï¼ˆInput Iteratorsï¼‰ï¼š** æ”¯æŒå•æ¬¡è¯»å–ã€‚
   - **è¾“å‡ºè¿­ä»£å™¨ï¼ˆOutput Iteratorsï¼‰ï¼š** æ”¯æŒå•æ¬¡å†™å…¥ã€‚
   - **å‰å‘è¿­ä»£å™¨ï¼ˆForward Iteratorsï¼‰ï¼š** æ”¯æŒå•å‘éå†ã€‚
   - **åŒå‘è¿­ä»£å™¨ï¼ˆBidirectional Iteratorsï¼‰ï¼š** æ”¯æŒåŒå‘éå†ã€‚
   - **éšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆRandom Access Iteratorsï¼‰ï¼š** æ”¯æŒéšæœºè®¿é—®ã€‚
5. **ç®—æ³•æ—¶é—´å¤æ‚åº¦ï¼š**
   - å¤§å¤šæ•° STL ç®—æ³•éƒ½ä»¥çº¿æ€§å¯¹æ•°ï¼ˆO(n log n)ï¼‰æ—¶é—´è¿è¡Œï¼Œå…¶ä¸­ n æ˜¯åºåˆ—çš„å¤§å°ã€‚

ğŸ‘ é€šå¸¸è¿­ä»£å™¨ä½œä¸ºé“¾æ¥å®¹å™¨å’Œç®—æ³•çš„æ¡¥æ¢ã€‚

STL æä¾›äº†ä¸°å¯Œçš„åŠŸèƒ½ï¼Œå¯ä»¥å¤§å¤§ç®€åŒ– C++ç¨‹åºçš„å¼€å‘ã€‚åœ¨ä½¿ç”¨ STL æ—¶ï¼Œä½ å¯ä»¥éµå¾ªä¸€äº›æœ€ä½³å®è·µï¼Œä¾‹å¦‚ä½¿ç”¨è¿­ä»£å™¨è€Œéç´¢å¼•è¿›è¡Œéå†ï¼Œå–„ç”¨ç®—æ³•åº“ç­‰ï¼Œä»¥æé«˜ä»£ç çš„å¯è¯»æ€§å’Œæ€§èƒ½ã€‚

## å®¹å™¨

### åºåˆ—å®¹å™¨

#### Vector

C++ ä¸­çš„ `std::vector` æ˜¯æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰ä¸­çš„ä¸€ä¸ªåŠ¨æ€æ•°ç»„å®ç°ã€‚å®ƒæä¾›äº†åŠ¨æ€å¤§å°çš„æ•°ç»„ï¼Œæ”¯æŒé«˜æ•ˆçš„å…ƒç´ æ’å…¥å’Œåˆ é™¤ã€‚ä»¥ä¸‹æ˜¯å…³äº `std::vector` çš„ä¸€äº›åŸºæœ¬ä¿¡æ¯å’Œç”¨æ³•ï¼š

##### åŒ…å«å¤´æ–‡ä»¶

åœ¨ä½¿ç”¨ `std::vector` ä¹‹å‰ï¼Œéœ€è¦åŒ…å« `<vector>` å¤´æ–‡ä»¶ï¼š

```
#include <vector>
```

##### åˆ›å»ºå’Œåˆå§‹åŒ–

å¯ä»¥ä½¿ç”¨ä¸åŒçš„æ–¹å¼æ¥åˆ›å»ºå’Œåˆå§‹åŒ– `std::vector`ã€‚

```cpp
#include <vector>

int main() {
    // é€šè¿‡åˆå§‹åŒ–åˆ—è¡¨åˆ›å»º
    std::vector<int> vec1 = {1, 2, 3, 4, 5};

    // é€šè¿‡æŒ‡å®šå¤§å°å’Œåˆå§‹å€¼åˆ›å»º
    std::vector<int> vec2(5, 10); // åŒ…å«äº”ä¸ªå…ƒç´ ï¼Œæ¯ä¸ªå…ƒç´ çš„å€¼ä¸º 10

    // é»˜è®¤æ„é€ å‡½æ•°åˆ›å»ºç©ºçš„ vector
    std::vector<int> vec3;

    return 0;
}

```

##### è®¿é—®å…ƒç´ 

å¯ä»¥ä½¿ç”¨ç´¢å¼•è®¿é—® `std::vector` çš„å…ƒç´ ï¼Œç´¢å¼•ä» 0 å¼€å§‹ã€‚

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // è®¿é—®å…ƒç´ 
    std::cout << "Element at index 2: " << vec[2] << std::endl;

    return 0;
}

```

##### æ·»åŠ å’Œåˆ é™¤å…ƒç´ 

`std::vector` æä¾›äº† `push_back` å’Œ `pop_back` å‡½æ•°ç”¨äºåœ¨å°¾éƒ¨æ·»åŠ å’Œåˆ é™¤å…ƒç´ ã€‚

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // æ·»åŠ å…ƒç´ 
    vec.push_back(6);

    // åˆ é™¤å°¾éƒ¨å…ƒç´ 
    vec.pop_back();

    // æ˜¾ç¤º vector ä¸­çš„å…ƒç´ 
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

##### è¿­ä»£

å¯ä»¥ä½¿ç”¨è¿­ä»£å™¨éå† `std::vector`ã€‚

```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};

    // ä½¿ç”¨è¿­ä»£å™¨éå†
    for (auto it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // ä½¿ç”¨èŒƒå›´-based for å¾ªç¯
    for (const auto& element : vec) {
        std::cout << element << " ";
    }
    std::cout << std::endl;

    return 0;
}

```

è¿™åªæ˜¯ `std::vector` çš„åŸºæœ¬ç”¨æ³•ç¤ºä¾‹ã€‚å®ƒè¿˜æä¾›äº†è®¸å¤šå…¶ä»–æ–¹æ³•å’ŒåŠŸèƒ½ï¼ŒåŒ…æ‹¬ä¿®æ”¹å…ƒç´ ã€æ¸…ç©ºå‘é‡ã€è·å–å‘é‡å¤§å°ç­‰ã€‚è¯¦ç»†ä¿¡æ¯å¯ä»¥æŸ¥é˜… C++ çš„æ–‡æ¡£æˆ–å‚è€ƒç›¸å…³æ•™ç¨‹ã€‚

#### list

```cpp
#include <iostream>
#include <list>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„ list
    std::list<int> myList;

    // åœ¨ list å°¾éƒ¨æ·»åŠ å…ƒç´ 
    myList.push_back(1);
    myList.push_back(2);
    myList.push_back(3);

    // åœ¨ list å¤´éƒ¨æ·»åŠ å…ƒç´ 
    myList.push_front(0);

    // ä½¿ç”¨è¿­ä»£å™¨éå† list
    for (auto it = myList.begin(); it != myList.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
    auto it = std::find(myList.begin(), myList.end(), 2);
    if (it != myList.end()) {
        myList.insert(it, 99);
    }

    // ç§»é™¤æŒ‡å®šå…ƒç´ 
    myList.remove(2);

    // åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
    myList.pop_front();

    // åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
    myList.pop_back();

    // è·å– list çš„å¤§å°
    std::cout << "Size: " << myList.size() << std::endl;

    // åˆ¤æ–­ list æ˜¯å¦ä¸ºç©º
    if (myList.empty()) {
        std::cout << "List is empty." << std::endl;
    } else {
        std::cout << "List is not empty." << std::endl;
    }

    return 0;
}

```

#### deque

```cpp
#include <iostream>
#include <deque>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„ deque
    std::deque<int> myDeque;

    // åœ¨ deque å°¾éƒ¨æ·»åŠ å…ƒç´ 
    myDeque.push_back(1);
    myDeque.push_back(2);
    myDeque.push_back(3);

    // åœ¨ deque å¤´éƒ¨æ·»åŠ å…ƒç´ 
    myDeque.push_front(0);

    // ä½¿ç”¨è¿­ä»£å™¨éå† deque
    for (auto it = myDeque.begin(); it != myDeque.end(); ++it) {
        std::cout << *it << " ";
    }
    std::cout << std::endl;

    // åœ¨æŒ‡å®šä½ç½®æ’å…¥å…ƒç´ 
    auto it = std::find(myDeque.begin(), myDeque.end(), 2);
    if (it != myDeque.end()) {
        myDeque.insert(it, 99);
    }

    // åˆ é™¤æŒ‡å®šå…ƒç´ 
    myDeque.erase(std::remove(myDeque.begin(), myDeque.end(), 2), myDeque.end());

    // åˆ é™¤ç¬¬ä¸€ä¸ªå…ƒç´ 
    myDeque.pop_front();

    // åˆ é™¤æœ€åä¸€ä¸ªå…ƒç´ 
    myDeque.pop_back();

    // è·å– deque çš„å¤§å°
    std::cout << "Size: " << myDeque.size() << std::endl;

    // åˆ¤æ–­ deque æ˜¯å¦ä¸ºç©º
    if (myDeque.empty()) {
        std::cout << "Deque is empty." << std::endl;
    } else {
        std::cout << "Deque is not empty." << std::endl;
    }

    return 0;
}

```

#### queue

```cpp
#include <iostream>
#include <queue>

int main() {
    // åˆ›å»ºä¸€ä¸ªç©ºçš„é˜Ÿåˆ—
    std::queue<int> myQueue;

    // å…¥é˜Ÿ
    myQueue.push(1);
    myQueue.push(2);
    myQueue.push(3);

    // æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    std::cout << "Front: " << myQueue.front() << std::endl;

    // å‡ºé˜Ÿ
    myQueue.pop();

    // å†æ¬¡æŸ¥çœ‹é˜Ÿå¤´å…ƒç´ 
    std::cout << "Front after pop: " << myQueue.front() << std::endl;

    // è·å–é˜Ÿåˆ—çš„å¤§å°
    std::cout << "Size: " << myQueue.size() << std::endl;

    // åˆ¤æ–­é˜Ÿåˆ—æ˜¯å¦ä¸ºç©º
    if (myQueue.empty()) {
        std::cout << "Queue is empty." << std::endl;
    } else {
        std::cout << "Queue is not empty." << std::endl;
    }

    return 0;
}

```

#### stack

```cpp
#include <iostream>
#include <stack>

int main() {
    std::stack<int> s;

    // ä½¿ç”¨pushæ¥å£æ·»åŠ å…ƒç´ 
    s.push(1);
    s.push(2);
    s.push(3);

    // ä½¿ç”¨topæ¥å£è®¿é—®æ ˆé¡¶å…ƒç´ 
    std::cout << "Top: " << s.top() << std::endl;

    // ä½¿ç”¨emptyå’Œsizeæ¥å£æ£€æŸ¥æ ˆæ˜¯å¦ä¸ºç©ºä»¥åŠæ ˆçš„å¤§å°
    std::cout << "Is empty: " << (s.empty() ? "Yes" : "No") << std::endl;
    std::cout << "Size: " << s.size() << std::endl;

    // ä½¿ç”¨popæ¥å£ç§»é™¤æ ˆé¡¶å…ƒç´ 
    s.pop();
    std::cout << "Top after pop: " << s.top() << std::endl;

    return 0;
}

```

### å…³è”å®¹å™¨

#### set

**`set`ï¼ˆé›†åˆï¼‰ï¼š**

* `std::set` æ˜¯C++æ ‡å‡†æ¨¡æ¿åº“ï¼ˆSTLï¼‰æä¾›çš„ä¸€ç§é›†åˆå®¹å™¨ã€‚
* ç‰¹ç‚¹ï¼š
  * å­˜å‚¨å”¯ä¸€çš„å…ƒç´ ï¼Œä¸å…è®¸é‡å¤ã€‚
  * è‡ªåŠ¨æ’åºå­˜å‚¨çš„å…ƒç´ ã€‚

```cpp
#include <set>
#include <iostream>

int main() {
    std::set<int> mySet = {3, 1, 4, 1, 5, 9, 2, 6};
    for (int x : mySet) {
        std::cout << x << " ";
    }
    return 0;
}
```

```cpp
std::set<T> mySet;           // ç©ºé›†åˆ
std::set<T> mySet(initializer_list);  // ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨åˆ›å»ºé›†åˆ

mySet.insert(element);       // æ’å…¥å…ƒç´ 

mySet.erase(element);        // ç§»é™¤æŒ‡å®šå…ƒç´ 
mySet.clear();               // ç§»é™¤æ‰€æœ‰å…ƒç´ 

auto it = mySet.find(element);   // è¿”å›æŒ‡å‘å…ƒç´ çš„è¿­ä»£å™¨

for (const auto& elem : mySet) {
    // éå†é›†åˆä¸­çš„å…ƒç´ 
}

```

#### mutiset

**`multiset`ï¼ˆå¤šé‡é›†åˆï¼‰ï¼š**

* `std::multiset` ä¹Ÿæ˜¯ä¸€ä¸ªé›†åˆå®¹å™¨ï¼Œä½†å…è®¸å­˜å‚¨é‡å¤çš„å…ƒç´ ã€‚
* ç‰¹ç‚¹ï¼š
  * å…è®¸å­˜å‚¨é‡å¤å…ƒç´ ã€‚
  * è‡ªåŠ¨æ’åºå­˜å‚¨çš„å…ƒç´ ã€‚

```cpp
#include <set>
#include <iostream>

int main() {
    std::multiset<int> myMultiset = {3, 1, 4, 1, 5, 9, 2, 6};
    for (int x : myMultiset) {
        std::cout << x << " ";
    }
    return 0;
}

```

```cpp
std::multiset<T> myMultiset;           // ç©ºå¤šé‡é›†åˆ
std::multiset<T> myMultiset(initializer_list);  // ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨åˆ›å»ºå¤šé‡é›†åˆ

myMultiset.insert(element);       // æ’å…¥å…ƒç´ 

myMultiset.erase(element);        // ç§»é™¤æŒ‡å®šå…ƒç´ 
myMultiset.clear();               // ç§»é™¤æ‰€æœ‰å…ƒç´ 

auto range = myMultiset.equal_range(element);   // è¿”å›æŒ‡å‘å…ƒç´ èŒƒå›´çš„è¿­ä»£å™¨å¯¹

for (const auto& elem : myMultiset) {
    // éå†å¤šé‡é›†åˆä¸­çš„å…ƒç´ 
}
```

#### map

**`map`ï¼ˆæ˜ å°„ï¼‰ï¼š**

* `std::map` æ˜¯C++ STLæä¾›çš„ä¸€ç§å…³è”å®¹å™¨ï¼Œç”¨äºå­˜å‚¨é”®å€¼å¯¹ã€‚
* ç‰¹ç‚¹ï¼š
  * é”®æ˜¯å”¯ä¸€çš„ï¼Œæ¯ä¸ªé”®å¯¹åº”ä¸€ä¸ªå€¼ã€‚
  * æ ¹æ®é”®è¿›è¡Œè‡ªåŠ¨æ’åºã€‚

```cpp
#include <map>
#include <iostream>

int main() {
    std::map<int, std::string> myMap = {{1, "one"}, {2, "two"}, {3, "three"}};
    for (const auto& pair : myMap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    return 0;
}

```

```cpp
myMap[key] = value;                  // æ’å…¥æˆ–æ›´æ–°é”®å€¼å¯¹

myMap.erase(key);                    // ç§»é™¤æŒ‡å®šé”®å€¼å¯¹
myMap.clear();                       // ç§»é™¤æ‰€æœ‰é”®å€¼å¯¹

auto it = myMap.find(key);           // è¿”å›æŒ‡å‘é”®å€¼å¯¹çš„è¿­ä»£å™¨

for (const auto& pair : myMap) {
    // éå†æ˜ å°„ä¸­çš„é”®å€¼å¯¹
}

```

#### mutimap

**`multimap`ï¼ˆå¤šé‡æ˜ å°„ï¼‰ï¼š**

* `std::multimap` ä¹Ÿæ˜¯ä¸€ä¸ªå…³è”å®¹å™¨ï¼Œå…è®¸å­˜å‚¨ç›¸åŒé”®çš„å¤šä¸ªé”®å€¼å¯¹ã€‚
* ç‰¹ç‚¹ï¼š
  * å…è®¸ç›¸åŒé”®å¯¹åº”å¤šä¸ªå€¼ã€‚
  * æ ¹æ®é”®è¿›è¡Œè‡ªåŠ¨æ’åºã€‚

```cpp
#include <map>
#include <iostream>

int main() {
    std::multimap<int, std::string> myMultimap = {{1, "one"}, {2, "two"}, {1, "uno"}};
    for (const auto& pair : myMultimap) {
        std::cout << pair.first << ": " << pair.second << std::endl;
    }
    return 0;
}

```

```cpp
myMultimap.insert(std::make_pair(key, value));  // æ’å…¥é”®å€¼å¯¹

myMultimap.erase(key);                // ç§»é™¤æŒ‡å®šé”®å€¼å¯¹
myMultimap.clear();                   // ç§»é™¤æ‰€æœ‰é”®å€¼å¯¹

myMultimap.erase(key);                // ç§»é™¤æŒ‡å®šé”®å€¼å¯¹
myMultimap.clear();                   // ç§»é™¤æ‰€æœ‰é”®å€¼å¯¹

auto range = myMultimap.equal_range(key);   // è¿”å›æŒ‡å‘é”®å€¼å¯¹èŒƒå›´çš„è¿­ä»£å™¨å¯¹

for (const auto& pair : myMultimap) {
    // éå†å¤šé‡æ˜ å°„ä¸­çš„é”®å€¼å¯¹
}

```

### æ— åºå®¹å™¨

åœ¨æ¯ä¸ªæœ‰åºå®¹å™¨å‰é¢+unordered_ï¼Œç”¨æ³•åŸºæœ¬ä¸€è‡´

ä¾‹å¦‚ï¼š`unordered_map/unordered_multimap,unordered_set/unordered_multiset`
